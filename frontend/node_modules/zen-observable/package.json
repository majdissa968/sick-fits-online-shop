{
  "_args": [
    [
      {
        "raw": "zen-observable@^0.8.0",
        "scope": null,
        "escapedName": "zen-observable",
        "name": "zen-observable",
        "rawSpec": "^0.8.0",
        "spec": ">=0.8.0 <0.9.0",
        "type": "range"
      },
      "/home/majd/Development/wes bos courses/Sick-fits-New/Advanced-React-master/sick-fits/frontend/node_modules/apollo-client"
    ]
  ],
  "_from": "zen-observable@^0.8.0",
  "_hasShrinkwrap": false,
  "_id": "zen-observable@0.8.13",
  "_location": "/zen-observable",
  "_nodeVersion": "11.1.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/zen-observable_0.8.13_1548198339505_0.11264679407674105"
  },
  "_npmUser": {
    "name": "zenparsing",
    "email": "zenparsing@gmail.com"
  },
  "_npmVersion": "6.4.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "zen-observable@^0.8.0",
    "scope": null,
    "escapedName": "zen-observable",
    "name": "zen-observable",
    "rawSpec": "^0.8.0",
    "spec": ">=0.8.0 <0.9.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apollo-client",
    "/zen-observable-ts"
  ],
  "_resolved": "https://registry.npmjs.org/zen-observable/-/zen-observable-0.8.13.tgz",
  "_shasum": "a9f1b9dbdfd2d60a08761ceac6a861427d44ae2e",
  "_shrinkwrap": null,
  "_spec": "zen-observable@^0.8.0",
  "_where": "/home/majd/Development/wes bos courses/Sick-fits-New/Advanced-React-master/sick-fits/frontend/node_modules/apollo-client",
  "bugs": {
    "url": "https://github.com/zenparsing/zen-observable/issues"
  },
  "dependencies": {},
  "description": "An Implementation of ES Observables",
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-preset-es2015": "^6.24.1",
    "eslint": "^4.16.0",
    "mocha": "^5.0.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-fa+6aDUVvavYsefZw0zaZ/v3ckEtMgCFi30sn91SEZea4y/6jQp05E3omjkX91zV6RVdn15fqnFZ6RKjRGbp2g==",
    "shasum": "a9f1b9dbdfd2d60a08761ceac6a861427d44ae2e",
    "tarball": "https://registry.npmjs.org/zen-observable/-/zen-observable-0.8.13.tgz",
    "fileCount": 36,
    "unpackedSize": 71359,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcR6HECRA9TVsSAnZWagAA1Z4P/iaTdNSswH7q2aa2knrl\njswVKHKJlPSTI80dDoRAqC1TQ9Tiz/RYpDFqZ/0ozAbamPgXFHPHLt5wENd7\nToLCQRJNT8y7QR7hxpz5rjBxqTO2OxlzGRu2LwxeGVtU+UAOq6jR3SN+mp9U\n5ZA7awdgCEbP3T+57PALdbrztd9EQiLqY7SoyVZzfJaDuzFG/uXhhMbTcgPn\ndLIuw0VsfCkb3mIhpRUiyP1DhvqHARvdpwwma1TLSi0Z16fra5Sqzbpg7ubU\nDxaRX4qyHnj2DQgHbuZwirc9hcU9F8jqCRb54IwLfTLWuZmPOSOJm0FC5W9i\nQGe1uexSrqxM/QmFRvLvZhruQ7VWAQLzswn2FxJdJXFj3y4ON7TSMuDw6e7j\nycE0IoGBdY4qQFgmYLp4PANYnbrIOAhLzf9TbXK7O51l7W+V0Bg1VGP8H1C+\nrzXWplqJ+bwY614WPNlj4amDRoHuHM/AzZxkVVLbmSW6hxuvxNZJVmdY3HPF\ngLfcACFFZ9K3L09D7KCVuMbIP0aQ8zsheJQ6ZqVBKbaQr0rvouXouN8STMRF\n5YMImGpdZ8XENJP0n+Y5YfrEAUzkxWMGReSAh5Mo+kKi7dSyM+rHZXiQ+Ofj\nGRWyzlzb7ZRjys9AJzzfahQuP5e9k10i75zVX67ixQjoSr0yiSp+wTWD5hFB\nAv4e\r\n=iag8\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "3f76d59e6d8ff426c3825946849e21d77aea5c15",
  "homepage": "https://github.com/zenparsing/zen-observable",
  "license": "MIT",
  "maintainers": [
    {
      "name": "zenparsing",
      "email": "zenparsing@gmail.com"
    }
  ],
  "name": "zen-observable",
  "optionalDependencies": {},
  "readme": "# zen-observable\n\nAn implementation of Observables for JavaScript. Requires Promises or a Promise polyfill.\n\n## Install\n\n```sh\nnpm install zen-observable\n```\n\n## Usage\n\n```js\nimport Observable from 'zen-observable';\n\nObservable.of(1, 2, 3).subscribe(x => console.log(x));\n```\n\n## API\n\n### new Observable(subscribe)\n\n```js\nlet observable = new Observable(observer => {\n  // Emit a single value after 1 second\n  let timer = setTimeout(() => {\n    observer.next('hello');\n    observer.complete();\n  }, 1000);\n\n  // On unsubscription, cancel the timer\n  return () => clearTimeout(timer);\n});\n```\n\nCreates a new Observable object using the specified subscriber function.  The subscriber function is called whenever the `subscribe` method of the observable object is invoked.  The subscriber function is passed an *observer* object which has the following methods:\n\n- `next(value)` Sends the next value in the sequence.\n- `error(exception)` Terminates the sequence with an exception.\n- `complete()` Terminates the sequence successfully.\n- `closed` A boolean property whose value is `true` if the observer's subscription is closed.\n\nThe subscriber function can optionally return either a cleanup function or a subscription object.  If it returns a cleanup function, that function will be called when the subscription has closed.  If it returns a subscription object, then the subscription's `unsubscribe` method will be invoked when the subscription has closed.\n\n### Observable.of(...items)\n\n```js\n// Logs 1, 2, 3\nObservable.of(1, 2, 3).subscribe(x => {\n  console.log(x);\n});\n```\n\nReturns an observable which will emit each supplied argument.\n\n### Observable.from(value)\n\n```js\nlet list = [1, 2, 3];\n\n// Iterate over an object\nObservable.from(list).subscribe(x => {\n  console.log(x);\n});\n```\n\n```js\n// Convert something 'observable' to an Observable instance\nObservable.from(otherObservable).subscribe(x => {\n  console.log(x);\n});\n```\n\nConverts `value` to an Observable.\n\n- If `value` is an implementation of Observable, then it is converted to an instance of Observable as defined by this library.\n- Otherwise, it is converted to an Observable which synchronously iterates over `value`.\n\n### observable.subscribe([observer])\n\n```js\nlet subscription = observable.subscribe({\n  next(x) { console.log(x) },\n  error(err) { console.log(`Finished with error: ${ err }`) },\n  complete() { console.log('Finished') }\n});\n```\n\nSubscribes to the observable.  Observer objects may have any of the following methods:\n\n- `next(value)` Receives the next value of the sequence.\n- `error(exception)` Receives the terminating error of the sequence.\n- `complete()` Called when the stream has completed successfully.\n\nReturns a subscription object that can be used to cancel the stream.\n\n### observable.subscribe(nextCallback[, errorCallback, completeCallback])\n\n```js\nlet subscription = observable.subscribe(\n  x => console.log(x),\n  err => console.log(`Finished with error: ${ err }`),\n  () => console.log('Finished')\n);\n```\n\nSubscribes to the observable with callback functions. Returns a subscription object that can be used to cancel the stream.\n\n### observable.forEach(callback)\n\n```js\nobservable.forEach(x => {\n  console.log(`Received value: ${ x }`);\n}).then(() => {\n  console.log('Finished successfully')\n}).catch(err => {\n  console.log(`Finished with error: ${ err }`);\n})\n```\n\nSubscribes to the observable and returns a Promise for the completion value of the stream.  The `callback` argument is called once for each value in the stream.\n\n### observable.filter(callback)\n\n```js\nObservable.of(1, 2, 3).filter(value => {\n  return value > 2;\n}).subscribe(value => {\n  console.log(value);\n});\n// 3\n```\n\nReturns a new Observable that emits all values which pass the test implemented by the `callback` argument.\n\n### observable.map(callback)\n\nReturns a new Observable that emits the results of calling the `callback` argument for every value in the stream.\n\n```js\nObservable.of(1, 2, 3).map(value => {\n  return value * 2;\n}).subscribe(value => {\n  console.log(value);\n});\n// 2\n// 4\n// 6\n```\n\n### observable.reduce(callback [,initialValue])\n\n```js\nObservable.of(0, 1, 2, 3, 4).reduce((previousValue, currentValue) => {\n  return previousValue + currentValue;\n}).subscribe(result => {\n  console.log(result);\n});\n// 10\n```\n\nReturns a new Observable that applies a function against an accumulator and each value of the stream to reduce it to a single value.\n\n### observable.concat(...sources)\n\n```js\nObservable.of(1, 2, 3).concat(\n  Observable.of(4, 5, 6),\n  Observable.of(7, 8, 9)\n).subscribe(result => {\n  console.log(result);\n});\n// 1, 2, 3, 4, 5, 6, 7, 8, 9\n```\n\nMerges the current observable with additional observables.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zenparsing/zen-observable.git"
  },
  "scripts": {
    "build": "git clean -dfX ./lib && node ./scripts/build",
    "lint": "eslint src/*",
    "prepublishOnly": "eslint src/* && npm test && npm run build",
    "test": "mocha --recursive --require ./scripts/mocha-require"
  },
  "version": "0.8.13"
}
